-- Venom Hub
-- V.1.3 (Updated with new features)

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Vevo Hub v1.3',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Interpolation = Window:AddTab('Interpolation'),
    Configuration = Window:AddTab('Configuration'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- Helper function to get animation ID based on Rin Pack toggle
local function getAnimationID(defaultID)
    if Toggles.RinPackToggle and Toggles.RinPackToggle.Value then
        return '"rbxassetid://11883854957696"'
    else
        return '"' .. defaultID .. '"'
    end
end

-- Helper function to get keybind enum
local function getKeybindEnum(keybindOption)
    if keybindOption and keybindOption.Value then
        return 'Enum.KeyCode.' .. keybindOption.Value
    else
        return 'nil' -- Will use default in script
    end
end

-- LEFT SIDE GROUPS (MAIN TAB)
local SpeedGroup = Tabs.Main:AddLeftGroupbox('Speed Hack')
SpeedGroup:AddToggle('SpeedToggle', {
    Text = 'Enable Speed Hack',
    Default = false,
    Callback = function(Value)
        if Value then
            local speedValue = Options.SpeedSlider.Value
            loadstring([[
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local PSSettings = ReplicatedStorage:WaitForChild("PSSettings")
                local runSpeedMult = PSSettings:WaitForChild("RunSpeedMult")
                local LOCKED_VALUE = ]] .. speedValue .. [[
                runSpeedMult.Value = LOCKED_VALUE
                runSpeedMult:GetPropertyChangedSignal("Value"):Connect(function()
                    if runSpeedMult.Value ~= LOCKED_VALUE then
                        runSpeedMult.Value = LOCKED_VALUE
                    end
                end)
                task.spawn(function()
                    while true do
                        if runSpeedMult.Value ~= LOCKED_VALUE then
                            runSpeedMult.Value = LOCKED_VALUE
                        end
                        task.wait(0.05)
                    end
                end)
            ]])()
        end
    end
})

SpeedGroup:AddSlider('SpeedSlider', {
    Text = 'Speed Multiplier',
    Default = 1.03,
    Min = 1.00,
    Max = 5.00,
    Rounding = 2,
    Callback = function(Value)
        if Toggles.SpeedToggle.Value then
            loadstring([[
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local PSSettings = ReplicatedStorage:WaitForChild("PSSettings")
                local runSpeedMult = PSSettings:WaitForChild("RunSpeedMult")
                runSpeedMult.Value = ]] .. Value .. [[
            ]])()
        end
    end
})

local StaminaGroup = Tabs.Main:AddLeftGroupbox('Stamina')
StaminaGroup:AddToggle('StaminaToggle', {
    Text = 'Infinite Stamina',
    Default = false,
    Callback = function(Value)
        if Value then
            loadstring([[
                getgenv().on = true
                while on do
                wait()
                local playerStats = game.Players.LocalPlayer.Character:FindFirstChild("Stats")
                if playerStats then
                    playerStats.Stamina.Value = 100
                    playerStats.StaminaCheck.Value = 100
                end
                wait()
                end
            ]])()
        else
            getgenv().on = false
        end
    end
})

local KickGroup = Tabs.Main:AddLeftGroupbox('No Kick CD')
KickGroup:AddToggle('KickToggle', {
    Text = 'No Kick Cooldown',
    Default = false,
    Callback = function(Value)
        if Value then
            loadstring([[
                getgenv().on = true
                while on do
                if game.Players.LocalPlayer.Character.Status:FindFirstChild("KickCD") then
                    game.Players.LocalPlayer.Character.Status:FindFirstChild("KickCD"):Destroy()
                end
                wait()
                end
            ]])()
        else
            getgenv().on = false
        end
    end
})

local LastDiscGroup = Tabs.Main:AddLeftGroupbox('Auto Last Disc')
LastDiscGroup:AddToggle('LastDiscToggle', {
    Text = 'Enable Auto Last Disc',
    Default = false,
    Callback = function(Value)
        if Value then
            Library:Notify('Auto Last Disc is not functional yet', 3)
        end
    end
})

if Options.LastDiscKeybind then
    LastDiscGroup:AddLabel('Keybind: ' .. Options.LastDiscKeybind.Value)
end

-- COMBAT FEATURES IN MAIN TAB
local AimGroup = Tabs.Main:AddLeftGroupbox('Aimbot V1')
AimGroup:AddToggle('AimbotToggle', {
    Text = 'Enable Aimbot V1',
    Default = false,
    Callback = function(Value)
        if Value then
            local animationId = getAnimationID('rbxassetid://15434792076')
            local highKey = getKeybindEnum(Options.AimbotHighKeybind) or 'Enum.KeyCode.V'
            local lowKey = getKeybindEnum(Options.AimbotLowKeybind) or 'Enum.KeyCode.B'
            local powerValue = Options.AimbotPowerSlider and Options.AimbotPowerSlider.Value or 100
            
            local script = [[
                --!nocheck
                local Players = game:GetService('Players')
                local ReplicatedStorage = game:GetService('ReplicatedStorage')
                local UserInputService = game:GetService('UserInputService')
                local Workspace = game:GetService('Workspace')
                local RunService = game:GetService('RunService')

                -- Knit Setup
                local Knit = require(ReplicatedStorage.Packages.Knit)
                local KeyHandlerService = Knit.GetService('KeyHandlerService')
                local kickRemote = KeyHandlerService:GetKey('Kick')

                -- Settings
                local camera = Workspace.CurrentCamera
                local smoothness = 0.4 
                local midfieldZ = 22
                local animationId = ]] .. animationId .. [[

                -- Goal X Coordinates
                local RIGHT_X = 280 
                local LEFT_X = 252  

                -- Auto Volley Config
                local HITBOX_SIZE = 6
                local KICK_COOLDOWN = 0.6 

                local activeMode = 0 -- 0 = Off, 1 = High (V), 2 = Low (B)
                local lastKickTime = 0
                local POWER_VALUE = ]] .. powerValue .. [[

                -- GUI SETUP
                local player = Players.LocalPlayer
                local pGui = player:WaitForChild("PlayerGui")

                if pGui:FindFirstChild("VolleyGui") then pGui.VolleyGui:Destroy() end

                local screenGui = Instance.new("ScreenGui")
                screenGui.Name = "VolleyGui"
                screenGui.Parent = pGui

                local statusLabel = Instance.new("TextLabel")
                statusLabel.Size = UDim2.new(0, 220, 0, 50)
                statusLabel.Position = UDim2.new(0.5, -110, 0.85, 0)
                statusLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                statusLabel.TextSize = 16
                statusLabel.Font = Enum.Font.GothamBold
                statusLabel.Text = "SYSTEM: READY"
                statusLabel.BorderSizePixel = 2
                statusLabel.Parent = screenGui

                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, 8)
                corner.Parent = statusLabel

                local powerLabel = Instance.new("TextLabel")
                powerLabel.Size = UDim2.new(0, 150, 0, 30)
                powerLabel.Position = UDim2.new(0.5, -75, 0.9, 0)
                powerLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                powerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                powerLabel.TextSize = 14
                powerLabel.Font = Enum.Font.GothamBold
                powerLabel.Text = "POWER: " .. POWER_VALUE
                powerLabel.BorderSizePixel = 2
                powerLabel.Parent = screenGui
                Instance.new("UICorner", powerLabel)

                local function updateGui(text, color)
                    statusLabel.Text = text
                    statusLabel.TextColor3 = color
                end

                local function updatePower(value)
                    POWER_VALUE = value
                    powerLabel.Text = "POWER: " .. value
                end

                -- LOGIC FUNCTIONS
                local function playAnimation(character)
                    local humanoid = character:FindFirstChildOfClass('Humanoid')
                    local animator = humanoid and (humanoid:FindFirstChildOfClass('Animator') or humanoid:WaitForChild('Animator'))
                    if animator then
                        local animation = Instance.new('Animation')
                        animation.AnimationId = animationId
                        local track = animator:LoadAnimation(animation)
                        track:Play()
                    end
                end

                local function getTargetX(humanoid)
                    local moveDir = humanoid.MoveDirection
                    if moveDir.X > 0.1 then
                        return RIGHT_X
                    elseif moveDir.X < -0.1 then
                        return LEFT_X
                    else
                        return RIGHT_X 
                    end
                end

                local function performKick()
                    local char = player.Character
                    local root = char and char:FindFirstChild("HumanoidRootPart")
                    local ball = Workspace:FindFirstChild('Temp') and Workspace.Temp:FindFirstChild('Ball')
                    
                    if root and ball then
                        lastKickTime = tick()

                        local direction = camera.CFrame.LookVector * 200
                        local args = {
                            direction, ball, false, true, POWER_VALUE, 'Right', root.CFrame, {}, false, false
                        }
                        kickRemote:FireServer(table.unpack(args))
                        char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        playAnimation(char)
                        
                        -- Reset state after successful kick
                        activeMode = 0 
                        updateGui("SYSTEM: READY", Color3.fromRGB(255, 255, 255))
                    end
                end

                -- INPUT LOGIC
                UserInputService.InputBegan:Connect(function(input, processed)
                    if processed then return end

                    if input.KeyCode == ]] .. highKey .. [[ then
                        if activeMode == 1 then 
                            activeMode = 0 
                            updateGui("SYSTEM: READY", Color3.fromRGB(255, 255, 255))
                        else
                            activeMode = 1 
                            updateGui("MODE: HIGH (AUTO-VOLLEY)", Color3.fromRGB(0, 255, 0))
                        end
                    elseif input.KeyCode == ]] .. lowKey .. [[ then
                        if activeMode == 2 then 
                            activeMode = 0 
                            updateGui("SYSTEM: READY", Color3.fromRGB(255, 255, 255))
                        else
                            activeMode = 2
                            updateGui("MODE: LOW (AUTO-VOLLEY)", Color3.fromRGB(85, 170, 255))
                        end
                    end
                end)

                -- UPDATE LOOP
                RunService.RenderStepped:Connect(function()
                    local char = player.Character
                    local root = char and char:FindFirstChild("HumanoidRootPart")
                    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                    if not root or not humanoid then return end

                    -- Handle Camera Zoom/Lock
                    if activeMode ~= 0 then
                        local currentTargetX = getTargetX(humanoid)
                        local baseTargetY = (activeMode == 1) and 19.80 or 9.68
                        local targetZ = (root.Position.Z < midfieldZ) and -254.21 or 300
                        
                        local finalTarget = Vector3.new(currentTargetX, baseTargetY, targetZ)
                        
                        -- High Mode Height Scaling
                        if activeMode == 1 then
                            local distance = (root.Position - finalTarget).Magnitude
                            local heightOffset = (distance / 40) + (distance^2 / 4000)
                            finalTarget = Vector3.new(finalTarget.X, baseTargetY + heightOffset, targetZ)
                        end
                        
                        -- Camera Zoom (Snapping to Target)
                        local targetCF = CFrame.lookAt(camera.CFrame.Position, finalTarget)
                        camera.CFrame = camera.CFrame:Lerp(targetCF, smoothness)

                        -- Auto-Volley Proximity Logic
                        local ballFolder = Workspace:FindFirstChild('Temp')
                        local ball = ballFolder and ballFolder:FindFirstChild('Ball')
                        
                        if ball then
                            local distance = (root.Position - ball.Position).Magnitude
                            if distance <= HITBOX_SIZE and (tick() - lastKickTime >= KICK_COOLDOWN) then
                                performKick()
                            end
                        end
                    end
                end)
            ]]
            loadstring(script)()
        end
    end
})

local highKeyText = Options.AimbotHighKeybind and Options.AimbotHighKeybind.Value or 'V'
local lowKeyText = Options.AimbotLowKeybind and Options.AimbotLowKeybind.Value or 'B'
AimGroup:AddLabel('High Mode: ' .. highKeyText)
AimGroup:AddLabel('Low Mode: ' .. lowKeyText)
AimGroup:AddSlider('AimbotPowerSlider', {
    Text = 'Kick Power',
    Default = 100,
    Min = 100,
    Max = 999,
    Rounding = 0,
    Callback = function(Value)
        if Toggles.AimbotToggle.Value then
            loadstring([[
                if getgenv().updatePower then
                    getgenv().updatePower(]] .. Value .. [[)
                end
            ]])()
        end
    end
})

-- Aimbot V2 Group
local AimbotV2Group = Tabs.Main:AddLeftGroupbox('Aimbot V2')
AimbotV2Group:AddToggle('AimbotV2Toggle', {
    Text = 'Enable Aimbot V2',
    Default = false,
    Callback = function(Value)
        if Value then
            local rangeValue = Options.AimbotV2RangeSlider and Options.AimbotV2RangeSlider.Value or 7
            local cooldownValue = Options.AimbotV2CooldownSlider and Options.AimbotV2CooldownSlider.Value or 1
            local powerValue = Options.AimbotV2PowerSlider and Options.AimbotV2PowerSlider.Value or 140
            local topKey = getKeybindEnum(Options.AimbotV2TopKeybind) or 'Enum.KeyCode.One'
            local bottomKey = getKeybindEnum(Options.AimbotV2BottomKeybind) or 'Enum.KeyCode.Two'
            
            local script = [[
                -- // Auto Top Bins Standalone //
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Workspace = game:GetService("Workspace")
                local RunService = game:GetService("RunService")
                local UserInputService = game:GetService("UserInputService")

                local player = Players.LocalPlayer
                local Knit = require(ReplicatedStorage.Packages.Knit)
                local KeyHandlerService = Knit.GetService("KeyHandlerService")
                local kickRemote = KeyHandlerService:GetKey("Kick")

                -- Settings
                local FIRE_RANGE = ]] .. rangeValue .. [[
                local COOLDOWN = ]] .. cooldownValue .. [[

                -- State
                local topEnabled = false
                local bottomEnabled = false
                local lastFire = 0

                --------------------------------------------------
                -- UI INDICATOR
                --------------------------------------------------
                local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
                gui.Name = "AutoBinsIndicator"

                local function mkLabel(y, text)
                    local l = Instance.new("TextLabel")
                    l.Parent = gui
                    l.Size = UDim2.new(0, 120, 0, 30)
                    l.Position = UDim2.new(1, -130, 0, y)
                    l.BackgroundTransparency = 0.5
                    l.BackgroundColor3 = Color3.new(0, 0, 0)
                    l.TextColor3 = Color3.new(1, 1, 1)
                    l.TextScaled = true
                    l.Font = Enum.Font.SourceSansBold
                    l.Text = text
                    return l
                end

                local topLbl = mkLabel(10, "TOP OFF")
                local botLbl = mkLabel(45, "BOT OFF")

                local function updateUI()
                    topLbl.Text = topEnabled and "TOP ON" or "TOP OFF"
                    topLbl.TextColor3 = topEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    
                    botLbl.Text = bottomEnabled and "BOT ON" or "BOT OFF"
                    botLbl.TextColor3 = bottomEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                end

                --------------------------------------------------
                -- LOGIC
                --------------------------------------------------
                local function getBall()
                    local temp = Workspace:FindFirstChild("Temp")
                    return temp and temp:FindFirstChild("Ball")
                end

                local function getField()
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v.Name == "Field" and v:FindFirstChild("GoalboxHome") then return v end
                    end
                end

                local function getTarget(parts)
                    local cam = Workspace.CurrentCamera
                    local best, bestScore
                    for _, p in ipairs(parts) do
                        if p and p:IsA("BasePart") then
                            local dir = (p.Position - cam.CFrame.Position).Unit
                            local score = cam.CFrame.LookVector:Dot(dir)
                            if not bestScore or score > bestScore then
                                bestScore = score
                                best = p
                            end
                        end
                    end
                    return best
                end

                local function fire(target)
                    if tick() - lastFire < COOLDOWN then return end
                    lastFire = tick()

                    local ball = getBall()
                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    local hum = char and char:FindFirstChildOfClass("Humanoid")
                    if not ball or not hrp or not hum or not target then return end

                    -- Aim & Shoot
                    Workspace.CurrentCamera.CFrame = CFrame.new(Workspace.CurrentCamera.CFrame.Position, target.Position)
                    hrp.CFrame = CFrame.new(hrp.Position, Vector3.new(target.Position.X, hrp.Position.Y, target.Position.Z))

                    local side = hrp.CFrame.RightVector:Dot(ball.Position - hrp.Position) > 0 and "Right" or "Left"
                    kickRemote:FireServer((target.Position - hrp.Position).Unit * 200, ball, false, true, ]] .. powerValue .. [[, side, hrp.CFrame, {Enum.KeyCode.One}, false, false)
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                end

                -- Keybind Listener
                UserInputService.InputBegan:Connect(function(input, gp)
                    if gp then return end
                    if input.KeyCode == ]] .. topKey .. [[ then
                        topEnabled = not topEnabled
                        bottomEnabled = false
                    elseif input.KeyCode == ]] .. bottomKey .. [[ then
                        bottomEnabled = not bottomEnabled
                        topEnabled = false
                    end
                    updateUI()
                end)

                -- Loop
                RunService.RenderStepped:Connect(function()
                    if not topEnabled and not bottomEnabled then return end
                    local ball = getBall()
                    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                    if ball and hrp and (ball.Position - hrp.Position).Magnitude <= FIRE_RANGE then
                        local f = getField()
                        if not f then return end
                        if topEnabled then
                            fire(getTarget({f.GoalboxHome["TOP RIGHT"], f.GoalboxHome["TOP LEFT"], f.GoalboxAway["TOP RIGHT"], f.GoalboxAway["TOP LEFT"]}))
                        else
                            fire(getTarget({f.GoalboxHome["BOTTOM RIGHT"], f.GoalboxHome["BOTTOM LEFT"], f.GoalboxAway["BOTTOM RIGHT"], f.GoalboxAway["BOTTOM LEFT"]}))
                        end
                    end
                end)
            ]]
            loadstring(script)()
        end
    end
})

AimbotV2Group:AddSlider('AimbotV2RangeSlider', {
    Text = 'Range',
    Default = 7,
    Min = 1,
    Max = 20,
    Rounding = 0,
})

AimbotV2Group:AddSlider('AimbotV2CooldownSlider', {
    Text = 'Cooldown',
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
})

AimbotV2Group:AddSlider('AimbotV2PowerSlider', {
    Text = 'Power',
    Default = 140,
    Min = 100,
    Max = 999,
    Rounding = 0,
})

local PreholdGroup = Tabs.Main:AddLeftGroupbox('Auto Prehold')
PreholdGroup:AddToggle('PreholdToggle', {
    Text = 'Enable Auto Prehold',
    Default = false,
    Callback = function(Value)
        if Value then
            local animationId = getAnimationID('rbxassetid://15434792076')
            local procSize = Options.PreholdRangeSlider and Options.PreholdRangeSlider.Value or 4
            local toggleKey = getKeybindEnum(Options.PreholdToggleKeybind) or 'Enum.KeyCode.Four'
            local manualKey = getKeybindEnum(Options.PreholdManualKeybind) or 'Enum.KeyCode.G'
            
            local script = [[
                --!nocheck
                local Players = game:GetService('Players')
                local ReplicatedStorage = game:GetService('ReplicatedStorage')
                local UserInputService = game:GetService('UserInputService')
                local Workspace = game:GetService('Workspace')
                local RunService = game:GetService('RunService')

                local Knit = require(ReplicatedStorage.Packages.Knit)
                local KeyHandlerService = Knit.GetService('KeyHandlerService')

                -- Configuration
                local kickRemote = KeyHandlerService:GetKey('Kick')
                local animationId = ]] .. animationId .. [[
                local procSize = ]] .. procSize .. [[
                local HITBOX_SIZE = procSize
                local TOGGLE_KEY = ]] .. toggleKey .. [[
                local MANUAL_KEY = ]] .. manualKey .. [[

                local autoVolleyEnabled = false
                local lastKickTime = 0
                local KICK_COOLDOWN = 4

                -- Visual Circle
                local visualCircle = Instance.new("Part")
                visualCircle.Name = "RangeVisual"
                visualCircle.Shape = Enum.PartType.Cylinder
                visualCircle.Material = Enum.Material.ForceField
                visualCircle.Transparency = 0.5
                visualCircle.CanCollide = false
                visualCircle.CanQuery = false
                visualCircle.CanTouch = false
                visualCircle.Anchored = false
                visualCircle.Parent = Workspace

                local circleVisible = true
                local scriptActive = true

                local function updateCircle()
                    local character = Players.LocalPlayer.Character
                    local root = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if root and scriptActive and circleVisible then
                        local timeLeft = math.max(0, (lastKickTime + KICK_COOLDOWN) - tick())
                        
                        -- COLOR LOGIC: Red on CD, Green when Ready
                        if timeLeft > 0 then
                            visualCircle.Color = Color3.fromRGB(255, 50, 50) -- Red
                        else
                            visualCircle.Color = Color3.fromRGB(0, 255, 100) -- Green
                        end
                        
                        visualCircle.Transparency = 0.5
                        visualCircle.CFrame = root.CFrame * CFrame.new(0, -2.8, 0) * CFrame.Angles(0, 0, math.rad(90))
                        visualCircle.Size = Vector3.new(0.1, procSize * 2, procSize * 2)
                    else
                        visualCircle.Transparency = 1 -- Hide if script off or toggle off
                    end
                end

                -- GUI SETUP
                local screenGui = Instance.new("ScreenGui", game.CoreGui)
                local mainFrame = Instance.new("Frame", screenGui)
                mainFrame.Size = UDim2.new(0, 160, 0, 110)
                mainFrame.Position = UDim2.new(1, -170, 0, 140)
                mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
                mainFrame.BorderSizePixel = 0
                Instance.new("UICorner", mainFrame)

                local function createLabel(pos, text, color)
                    local lbl = Instance.new("TextLabel", mainFrame)
                    lbl.Size = UDim2.new(1, 0, 0.25, 0)
                    lbl.Position = pos
                    lbl.TextColor3 = color
                    lbl.Text = text
                    lbl.BackgroundTransparency = 1
                    lbl.Font = Enum.Font.GothamBold
                    lbl.TextSize = 12
                    return lbl
                end

                local statusLabel = createLabel(UDim2.new(0,0,0,0), "READY", Color3.new(0, 1, 0))
                local autoLabel = createLabel(UDim2.new(0,0,0.25,0), "AUTO (1): OFF", Color3.new(1, 0.3, 0.3))
                local procLabel = createLabel(UDim2.new(0,0,0.5,0), "RANGE (N-M): " .. procSize, Color3.new(1, 0.8, 0.2))
                local visualLabel = createLabel(UDim2.new(0,0,0.75,0), "CIRCLE (L): ON", Color3.new(0.7, 0.7, 0.7))

                -- Play kick animation function
                local function playAnimation(character)
                    local humanoid = character:FindFirstChildOfClass('Humanoid')
                    local animator = humanoid and (humanoid:FindFirstChildOfClass('Animator') or humanoid:WaitForChild('Animator'))
                    
                    if animator then
                        local animation = Instance.new('Animation')
                        animation.AnimationId = animationId
                        local track = animator:LoadAnimation(animation)
                        track:Play()
                    end
                end

                -- Logic to execute the kick
                local function performKick()
                    local player = Players.LocalPlayer
                    local character = player.Character
                    if not character then return end
                    
                    local root = character:FindFirstChild('HumanoidRootPart')
                    local humanoid = character:FindFirstChildOfClass('Humanoid')
                    if not root or not humanoid then return end

                    local ballFolder = Workspace:FindFirstChild('Temp')
                    local ball = ballFolder and ballFolder:FindFirstChild('Ball')
                    if not ball then return end

                    local distance = (root.Position - ball.Position).Magnitude
                    if distance <= procSize and (tick() - lastKickTime >= KICK_COOLDOWN) then
                        lastKickTime = tick()
                        
                        local direction = Workspace.CurrentCamera.CFrame.LookVector * 200
                        local args = { direction, ball, false, true, 100, 'Right', root.CFrame, {}, false, false }

                        kickRemote:FireServer(table.unpack(args))

                        local animator = humanoid and (humanoid:FindFirstChildOfClass('Animator') or humanoid:WaitForChild('Animator'))
                        if animator then
                            local anim = Instance.new('Animation')
                            anim.AnimationId = animationId
                            animator:LoadAnimation(anim):Play()
                        end
                    end
                end

                -- Toggle and Manual Input
                UserInputService.InputBegan:Connect(function(input, gp)
                    if gp then return end
                    
                    if input.KeyCode == TOGGLE_KEY then
                        autoVolleyEnabled = not autoVolleyEnabled
                        autoLabel.Text = "AUTO (1): " .. (autoVolleyEnabled and "ON" or "OFF")
                        autoLabel.TextColor3 = autoVolleyEnabled and Color3.new(0.3, 1, 0.3) or Color3.new(1, 0.3, 0.3)
                        print("Auto Volley: " .. (autoVolleyEnabled and "ENABLED" or "DISABLED"))
                    elseif input.KeyCode == MANUAL_KEY then
                        performKick()
                    elseif input.KeyCode == Enum.KeyCode.Zero then
                        scriptActive = not scriptActive
                        mainFrame.Visible = scriptActive
                    elseif input.KeyCode == Enum.KeyCode.L then -- Toggle Circle Visibility
                        circleVisible = not circleVisible
                        visualLabel.Text = "CIRCLE (L): " .. (circleVisible and "ON" or "OFF")
                    elseif input.KeyCode == Enum.KeyCode.M then
                        procSize = procSize + 0.5
                        procLabel.Text = "RANGE (N-M): " .. procSize
                    elseif input.KeyCode == Enum.KeyCode.N then
                        procSize = math.max(0.5, procSize - 0.5)
                        procLabel.Text = "RANGE (N-M): " .. procSize
                    end
                end)

                -- Update loop
                RunService.RenderStepped:Connect(function()
                    updateCircle()
                    
                    local timeLeft = math.max(0, (lastKickTime + KICK_COOLDOWN) - tick())
                    if not scriptActive then
                        statusLabel.Text = "DISABLED"
                        statusLabel.TextColor3 = Color3.new(0.5, 0.5, 0.5)
                    elseif timeLeft > 0 then
                        statusLabel.Text = string.format("CD: %.1fs", timeLeft)
                        statusLabel.TextColor3 = Color3.new(1, 0.2, 0.2)
                    else
                        statusLabel.Text = "READY"
                        statusLabel.TextColor3 = Color3.new(0, 1, 0)
                    end

                    if autoVolleyEnabled and scriptActive then
                        performKick()
                    end
                end)
            ]]
            loadstring(script)()
        end
    end
})

local toggleKeyText = Options.PreholdToggleKeybind and Options.PreholdToggleKeybind.Value or '4'
local manualKeyText = Options.PreholdManualKeybind and Options.PreholdManualKeybind.Value or 'G'
PreholdGroup:AddLabel('Toggle: ' .. toggleKeyText)
PreholdGroup:AddLabel('Manual: ' .. manualKeyText)
PreholdGroup:AddSlider('PreholdRangeSlider', {
    Text = 'Range',
    Default = 4,
    Min = 1,
    Max = 15,
    Rounding = 1,
})

local DoubleTapGroup = Tabs.Main:AddLeftGroupbox('Double Tap')
DoubleTapGroup:AddToggle('DoubleTapToggle', {
    Text = 'Enable Double Tap',
    Default = false,
    Callback = function(Value)
        if Value then
            local doubleTapKey = getKeybindEnum(Options.DoubleTapKeybind) or 'Enum.KeyCode.X'
            local chipAnimId = '"rbxassetid://15134077897"' -- Fixed animation ID (not affected by Rin Pack)
            
            local script = [[
                local Players = game:GetService('Players')
                local ReplicatedStorage = game:GetService('ReplicatedStorage')
                local UserInputService = game:GetService('UserInputService')
                local VirtualInputManager = game:GetService('VirtualInputManager')
                local Knit = require(ReplicatedStorage.Packages.Knit)

                local KeyHandlerService = Knit.GetService('KeyHandlerService')
                local KickRemote = KeyHandlerService:GetKey('Kick')
                local TapInRemote = KeyHandlerService:GetKey('TapInHit')

                local player = Players.LocalPlayer

                local CHIP_FORCE = 37.63837890769355
                local CHIP_VECTOR = Vector3.new(33.2738037109375, 27.290828704833984, -27.609731674194336)
                local CHIP_CFRAME = CFrame.new(216.23738, 12.676937, -96.496208, 0.6732608,0,-0.7394051,0,1,0,0.7394051,0,0.6732608)
                local CHIP_ANIM_ID = ]] .. chipAnimId .. [[

                local DTAP_FORCE = 27.13375797914341
                local DTAP_VECTOR = Vector3.new(14.2802124, 21.8535023, 32.024025)
                local DTAP_ANIM_ID = 'rbxassetid://16859143160'
                
                local lastActivation = 0
                local cooldown = 1.5
                local doubleTapKey = ]] .. doubleTapKey .. [[
                local doubleTapEnabled = true

                local function getBall()
                    local folder = workspace:FindFirstChild('Temp')
                    return folder and folder:FindFirstChild('Ball')
                end

                local function playAnimation(id)
                    local char = player.Character
                    if not char then return end
                    local hum = char:FindFirstChildOfClass('Humanoid')
                    local animator = hum and (hum:FindFirstChildOfClass('Animator') or Instance.new('Animator', hum))
                    if not animator then return end
                    local anim = Instance.new('Animation')
                    anim.AnimationId = id
                    animator:LoadAnimation(anim):Play()
                end

                local function alignVector(vec)
                    local camDir = workspace.CurrentCamera.CFrame.LookVector
                    local flat = Vector3.new(camDir.X,0,camDir.Z).Unit
                    local mag = Vector3.new(vec.X,0,vec.Z).Magnitude
                    return Vector3.new(flat.X*mag, vec.Y, flat.Z*mag)
                end

                UserInputService.InputBegan:Connect(function(i,gp)
                    if gp or i.KeyCode ~= doubleTapKey then return end
                    if not doubleTapEnabled then return end
                    
                    local currentTime = tick()
                    if currentTime - lastActivation < cooldown then return end
                    lastActivation = currentTime

                    local ball = getBall()
                    if not ball then return end

                    playAnimation(CHIP_ANIM_ID)
                    KickRemote:FireServer(
                        alignVector(CHIP_VECTOR), ball, false, false,
                        CHIP_FORCE, "Left", CHIP_CFRAME, {}, false, false
                    )

                    task.wait(0.2)
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                    task.wait(0.05)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)

                    task.wait(0.2)
                    playAnimation(DTAP_ANIM_ID)
                    TapInRemote:FireServer(ball, false, DTAP_FORCE, alignVector(DTAP_VECTOR), 'Right')
                end)
            ]]
            loadstring(script)()
        end
    end
})

local doubleTapKeyText = Options.DoubleTapKeybind and Options.DoubleTapKeybind.Value or 'X'
DoubleTapGroup:AddLabel('Keybind: ' .. doubleTapKeyText)

-- NEW AUTO M2 FEATURE
local AutoM2Group = Tabs.Main:AddLeftGroupbox('Auto M2')
AutoM2Group:AddToggle('AutoM2Toggle', {
    Text = 'Enable Auto M2',
    Default = false,
    Callback = function(Value)
        if Value then
            local autoM2Key = getKeybindEnum(Options.AutoM2Keybind) or 'Enum.KeyCode.Three'
            
            local script = [[
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Workspace = game:GetService("Workspace")
                local UserInputService = game:GetService("UserInputService")
                local RunService = game:GetService("RunService")
                local Players = game:GetService("Players")
                local VirtualInputManager = game:GetService("VirtualInputManager")
                local CoreGui = game:GetService("CoreGui")

                local player = Players.LocalPlayer
                local scriptActive = true         
                local autoM2Enabled = false       
                local lastHighlightState = false  
                local isBursting = false          

                local lastM2Time = 0
                local m2Interval = 0.2 
                local procSize = 4.5   

                ----------------------------------------------------------------
                -- VISUAL CIRCLE
                ----------------------------------------------------------------
                local visualCircle = Instance.new("Part")
                visualCircle.Name = "M2RangeVisual"
                visualCircle.Shape = Enum.PartType.Cylinder
                visualCircle.Material = Enum.Material.ForceField
                visualCircle.Transparency = 1 
                visualCircle.CanCollide = false
                visualCircle.CanQuery = false
                visualCircle.CanTouch = false
                visualCircle.Anchored = true
                visualCircle.Parent = Workspace

                local function updateCircle()
                    local character = player.Character
                    local root = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if root and scriptActive and autoM2Enabled then
                        visualCircle.Transparency = 0.5
                        if isBursting then
                            visualCircle.Color = Color3.fromRGB(255, 50, 50) -- Red during burst
                        else
                            visualCircle.Color = Color3.fromRGB(255, 255, 255) -- White when ready
                        end
                        
                        visualCircle.CFrame = root.CFrame * CFrame.new(0, -2.8, 0) * CFrame.Angles(0, 0, math.rad(90))
                        visualCircle.Size = Vector3.new(0.1, procSize * 2, procSize * 2)
                    else
                        visualCircle.Transparency = 1
                    end
                end

                ----------------------------------------------------------------
                -- GUI SETUP
                ----------------------------------------------------------------
                local screenGui = Instance.new("ScreenGui", CoreGui)
                local mainFrame = Instance.new("Frame", screenGui)
                mainFrame.Size = UDim2.new(0, 220, 0, 100)
                mainFrame.Position = UDim2.new(1, -230, 0, 10)
                mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
                Instance.new("UICorner", mainFrame)

                local function makeLabel(text, pos, size)
                    local lbl = Instance.new("TextLabel", mainFrame)
                    lbl.Size = size
                    lbl.Position = pos
                    lbl.BackgroundTransparency = 1
                    lbl.Font = Enum.Font.GothamBold
                    lbl.TextColor3 = Color3.fromRGB(200, 200, 200)
                    lbl.TextSize = 12
                    lbl.Text = text
                    return lbl
                end

                local statusLabel = makeLabel("AUTO M2: OFF", UDim2.new(0,0,0,0), UDim2.new(1,0,0.4,0))
                statusLabel.TextColor3 = Color3.fromRGB(255, 60, 60)
                local speedLabel = makeLabel("SPEED: 0.20s ([ / ])", UDim2.new(0,0,0.4,0), UDim2.new(1,0,0.3,0))
                local rangeLabel = makeLabel("RANGE: 4.5 (N / M)", UDim2.new(0,0,0.7,0), UDim2.new(1,0,0.3,0))

                ----------------------------------------------------------------
                -- UPDATED TIMING LOGIC
                ----------------------------------------------------------------

                -- Trigger: 0.2s delay -> M2 -> 0.2s delay -> M2
                local function runPostStealBurst()
                    if isBursting then return end
                    isBursting = true
                    
                    task.wait(0.2) -- First delay after steal highlight
                    
                    for i = 1, 2 do
                        VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 0)
                        task.wait(0.01)
                        VirtualInputManager:SendMouseButtonEvent(0, 0, 1, false, game, 0)
                        
                        if i < 2 then 
                            task.wait(0.2) -- Interval between the two M2s
                        end
                    end
                    
                    isBursting = false
                end

                local function isBallInAir(ball)
                    local char = player.Character
                    local root = char and char:FindFirstChild("HumanoidRootPart")
                    if root then
                        return (ball.Position.Y - root.Position.Y) > 6
                    end
                    return false
                end

                local function handleAutoM2(ball, highlight)
                    if not scriptActive or not autoM2Enabled then return end

                    -- Detect Possession
                    if highlight and not lastHighlightState then
                        lastHighlightState = true
                        task.spawn(runPostStealBurst)
                    elseif not highlight then
                        lastHighlightState = false
                    end

                    -- Skip regular spam if bursting, ball is high, or already have possession
                    if isBursting or highlight or isBallInAir(ball) then return end

                    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                    if root and (root.Position - ball.Position).Magnitude <= procSize then
                        if tick() - lastM2Time >= m2Interval then
                            lastM2Time = tick()
                            VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 0)
                            task.wait(0.01)
                            VirtualInputManager:SendMouseButtonEvent(0, 0, 1, false, game, 0)
                        end
                    end
                end

                ----------------------------------------------------------------
                -- RUNTIME
                ----------------------------------------------------------------
                RunService.RenderStepped:Connect(function()
                    updateCircle()
                    local ball = Workspace:FindFirstChild("Temp") and Workspace.Temp:FindFirstChild("Ball") or Workspace:FindFirstChild("Ball")
                    local highlight = ball and ball:FindFirstChild("PossessionHighlight")
                    if ball then handleAutoM2(ball, highlight) end
                end)

                UserInputService.InputBegan:Connect(function(input, gp)
                    if gp then return end
                    
                    if input.KeyCode == ]] .. autoM2Key .. [[ then
                        autoM2Enabled = not autoM2Enabled
                        statusLabel.Text = autoM2Enabled and "AUTO M2: ON" or "AUTO M2: OFF"
                        statusLabel.TextColor3 = autoM2Enabled and Color3.fromRGB(80, 255, 80) or Color3.fromRGB(255, 60, 60)
                        
                    elseif input.KeyCode == Enum.KeyCode.Zero then
                        scriptActive = not scriptActive
                        mainFrame.Visible = scriptActive
                        
                    elseif input.KeyCode == Enum.KeyCode.RightBracket then
                        m2Interval = math.clamp(m2Interval + 0.05, 0.05, 1.5)
                        speedLabel.Text = string.format("SPEED: %.2fs ([ / ])", m2Interval)
                        
                    elseif input.KeyCode == Enum.KeyCode.LeftBracket then
                        m2Interval = math.clamp(m2Interval - 0.05, 0.05, 1.5)
                        speedLabel.Text = string.format("SPEED: %.2fs ([ / ])", m2Interval)

                    elseif input.KeyCode == Enum.KeyCode.M then
                        procSize = math.clamp(procSize + 0.5, 1, 15)
                        rangeLabel.Text = "RANGE: " .. procSize .. " (N / M)"

                    elseif input.KeyCode == Enum.KeyCode.N then
                        procSize = math.clamp(procSize - 0.5, 1, 15)
                        rangeLabel.Text = "RANGE: " .. procSize .. " (N / M)"
                    end
                end)
            ]]
            loadstring(script)()
        end
    end
})

local autoM2KeyText = Options.AutoM2Keybind and Options.AutoM2Keybind.Value or '3'
AutoM2Group:AddLabel('Toggle: ' .. autoM2KeyText)
AutoM2Group:AddLabel('Speed: [ / ]')
AutoM2Group:AddLabel('Range: N / M')
AutoM2Group:AddLabel('Disable: 0')

-- NEW FEATURES GROUP
local NewFeaturesGroup = Tabs.Main:AddLeftGroupbox('New Features')

-- Phys Reach Feature
NewFeaturesGroup:AddToggle('PhysReachToggle', {
    Text = 'Enable Phys Reach',
    Default = false,
    Callback = function(Value)
        if Value then
            local physReachKey = getKeybindEnum(Options.PhysReachKeybind) or 'Enum.KeyCode.R'
            local animationId = '"rbxassetid://15417325996"' -- Fixed animation ID (not affected by Rin Pack)
            
            local script = [[
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local UserInputService = game:GetService("UserInputService")
                local Workspace = game:GetService("Workspace")


                local Knit = require(ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Knit"))
                local KeyHandlerService = Knit.GetService("KeyHandlerService")


                local shoveRemote = KeyHandlerService:GetKey("ShoveCheck") 

                local cooldownTime = 15
                local lastUsedTime = 0
                local animationId = ]] .. animationId .. [[


                local function getNearestPlayer()
                    local localPlayer = Players.LocalPlayer
                    local character = localPlayer.Character
                    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil

                    local nearestPlayer = nil
                    local shortestDistance = math.huge

                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local dist = (character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                            
                            if dist < shortestDistance then
                                shortestDistance = dist
                                nearestPlayer = player
                            end
                        end
                    end
                    return nearestPlayer
                end


                local function playShoveAnimation()
                    local character = Players.LocalPlayer.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                    local animator = humanoid and (humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator"))
                    
                    if animator then
                        local anim = Instance.new("Animation")
                        anim.AnimationId = animationId
                        local track = animator:LoadAnimation(anim)
                        track:Play()
                    end
                end


                local function executeShove()
                    local currentTime = tick()
                    if currentTime - lastUsedTime < cooldownTime then return end

                    
                    local ball = Workspace:FindFirstChild("Temp") and Workspace.Temp:FindFirstChild("Ball")
                    if not (ball and ball:FindFirstChild("PossessionHighlight")) then return end

                    local targetPlayer = getNearestPlayer()
                    if targetPlayer then
                        
                        local container = Workspace:FindFirstChild("CharacterContainer")
                        local targetChar = container and container:FindFirstChild(targetPlayer.Name)

                        if targetChar then
                            
                            shoveRemote:FireServer(targetChar)
                            
                            
                            playShoveAnimation()
                            lastUsedTime = currentTime
                            print("ShoveCheck fired at: " .. targetPlayer.Name)
                        end
                    end
                end


                UserInputService.InputBegan:Connect(function(input, processed)
                    if processed then return end
                    
                    if input.KeyCode == ]] .. physReachKey .. [[ then
                        executeShove()
                    end
                end)
            ]]
            loadstring(script)()
        end
    end
})

local physReachKeyText = Options.PhysReachKeybind and Options.PhysReachKeybind.Value or 'R'
NewFeaturesGroup:AddLabel('Phys Reach Key: ' .. physReachKeyText)

-- Auto Flick Feature
NewFeaturesGroup:AddToggle('AutoFlickToggle', {
    Text = 'Enable Auto Flick',
    Default = false,
    Callback = function(Value)
        if Value then
            local autoFlickKey = getKeybindEnum(Options.AutoFlickKeybind) or 'Enum.KeyCode.Five'
            local chipAnimId = '"rbxassetid://15134077897"' -- Fixed animation ID (not affected by Rin Pack)
            local powerValue = Options.AutoFlickPowerSlider and Options.AutoFlickPowerSlider.Value or 27.13
            local xValue = Options.AutoFlickXSlider and Options.AutoFlickXSlider.Value or 14.28
            local yValue = Options.AutoFlickYSlider and Options.AutoFlickYSlider.Value or 21.85
            local zValue = Options.AutoFlickZSlider and Options.AutoFlickZSlider.Value or 32.02
            
            local script = [[
                local Players = game:GetService('Players')
                local ReplicatedStorage = game:GetService('ReplicatedStorage')
                local UserInputService = game:GetService('UserInputService')
                local Knit = require(ReplicatedStorage.Packages.Knit)

                local KeyHandlerService = Knit.GetService('KeyHandlerService')
                local TapInRemote = KeyHandlerService:GetKey('TapInHit')

                local player = Players.LocalPlayer

                -- Swapped Animation ID
                local CHIP_ANIM_ID = ]] .. chipAnimId .. [[

                -- Using 2nd chip data
                local DTAP_FORCE = ]] .. powerValue .. [[
                local DTAP_VECTOR = Vector3.new(]] .. xValue .. [[, ]] .. yValue .. [[, ]] .. zValue .. [[)

                local function getBall()
                    local folder = workspace:FindFirstChild('Temp')
                    return folder and folder:FindFirstChild('Ball')
                end

                local function playAnimation(id)
                    local char = player.Character
                    if not char then return end
                    local hum = char:FindFirstChildOfClass('Humanoid')
                    local animator = hum and (hum:FindFirstChildOfClass('Animator') or Instance.new('Animator', hum))
                    if not animator then return end
                    
                    local anim = Instance.new('Animation')
                    anim.AnimationId = id
                    local track = animator:LoadAnimation(anim)
                    track:Play()
                end

                -- Calculation for direction + Character Flicking logic
                local function getDirectionAndFlick()
                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    local hum = char and char:FindFirstChild("Humanoid")
                    
                    if not hrp or not hum then return nil end
                    
                    local moveDir = hum.MoveDirection
                    
                    -- If standing still, use Camera direction
                    if moveDir.Magnitude == 0 then
                        local camDir = workspace.CurrentCamera.CFrame.LookVector
                        moveDir = Vector3.new(camDir.X, 0, camDir.Z).Unit
                    end
                    
                    -- FLICK: Rotate character to face the direction of the chip
                    hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + moveDir)
                    
                    local horizontalMag = Vector3.new(DTAP_VECTOR.X, 0, DTAP_VECTOR.Z).Magnitude
                    return Vector3.new(moveDir.X * horizontalMag, DTAP_VECTOR.Y, moveDir.Z * horizontalMag)
                end

                UserInputService.InputBegan:Connect(function(input, gp)
                    if gp or input.KeyCode ~= ]] .. autoFlickKey .. [[ then return end
                    
                    local ball = getBall()
                    if not ball then return end

                    local finalVector = getDirectionAndFlick()
                    if not finalVector then return end

                    playAnimation(CHIP_ANIM_ID)
                    TapInRemote:FireServer(ball, false, DTAP_FORCE, finalVector, 'Right')
                end)
            ]]
            loadstring(script)()
        end
    end
})

NewFeaturesGroup:AddSlider('AutoFlickPowerSlider', {
    Text = 'Flick Power',
    Default = 27.13,
    Min = 10,
    Max = 50,
    Rounding = 2,
})

NewFeaturesGroup:AddSlider('AutoFlickXSlider', {
    Text = 'Flick X Force',
    Default = 14.28,
    Min = 5,
    Max = 50,
    Rounding = 2,
})

NewFeaturesGroup:AddSlider('AutoFlickYSlider', {
    Text = 'Flick Y Force',
    Default = 21.85,
    Min = 5,
    Max = 50,
    Rounding = 2,
})

NewFeaturesGroup:AddSlider('AutoFlickZSlider', {
    Text = 'Flick Z Force',
    Default = 32.02,
    Min = 5,
    Max = 50,
    Rounding = 2,
})

local autoFlickKeyText = Options.AutoFlickKeybind and Options.AutoFlickKeybind.Value or '5'
NewFeaturesGroup:AddLabel('Auto Flick Key: ' .. autoFlickKeyText)

-- RIGHT SIDE GROUPS (MAIN TAB)
local TPMossGroup = Tabs.Main:AddRightGroupbox('TP Moss')
TPMossGroup:AddToggle('TPMossToggle', {
    Text = 'Enable TP Moss',
    Default = false,
    Callback = function(Value)
        if Value then
            local tpmossKey = getKeybindEnum(Options.TPMossKeybind) or 'Enum.KeyCode.Y'
            
            local script = [[
                local UserInputService = game:GetService("UserInputService")
                local Players = game:GetService("Players")
                local Workspace = game:GetService("Workspace")
                local RunService = game:GetService("RunService")

                local player = Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                local head = character:WaitForChild("Head")

                -- UI Setup
                local screenGui = Instance.new("ScreenGui")
                screenGui.Parent = player:WaitForChild("PlayerGui")

                local toggleLabel = Instance.new("TextLabel")
                toggleLabel.Size = UDim2.new(0, 200, 0, 50)
                toggleLabel.Position = UDim2.new(0.05, 0, 0.1, 0)
                toggleLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                toggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                toggleLabel.Font = Enum.Font.SourceSansBold
                toggleLabel.TextSize = 22
                toggleLabel.Text = "Toggled: OFF"
                toggleLabel.Parent = screenGui

                -- Variables
                local toggled = false
                local labelVisible = true
                local stepCount = 20
                local timeStep = 0.1
                local gravity = Vector3.new(0, -Workspace.Gravity * timeStep, 0)

                -- Toggle
                UserInputService.InputBegan:Connect(function(input, gameProcessed)
                	if gameProcessed then return end
                	
                	if input.KeyCode == ]] .. tpmossKey .. [[ then
                		toggled = not toggled
                		toggleLabel.Text = toggled and "Toggled: ON" or "Toggled: OFF"
                	elseif input.KeyCode == Enum.KeyCode.P then
                		labelVisible = not labelVisible
                		toggleLabel.Visible = labelVisible
                	end
                end)

                -- Predict Path Function
                local function isPlayerNearPredictedPath(ballPos, ballVel)
                	local currentPos = ballPos
                	local currentVel = ballVel

                	for _ = 1, stepCount do
                		currentVel += gravity
                		local nextPos = currentPos + currentVel * timeStep

                		if (humanoidRootPart.Position - nextPos).Magnitude <= 5 then
                			return true
                		end

                		currentPos = nextPos
                	end
                	return false
                end

                -- Main Loop
                RunService.Heartbeat:Connect(function()
                	if toggled then
                		local tempFolder = Workspace:FindFirstChild("Temp")
                		local ball = tempFolder and tempFolder:FindFirstChild("Ball")
                		if not ball or not ball:IsA("Part") then return end

                		if ball:FindFirstChild("PossessionHighlight") then
                			toggled = false
                			toggleLabel.Text = "Toggled: OFF"
                			return
                		end

                		local nearPath = isPlayerNearPredictedPath(ball.Position, ball.Velocity)
                		local nearBall = (ball.Position - humanoidRootPart.Position).Magnitude <= 7

                		if nearPath and nearBall then
                			ball.Position = head.Position
                		end
                	end
                end)
            ]]
            loadstring(script)()
        end
    end
})

local tpmossKeyText = Options.TPMossKeybind and Options.TPMossKeybind.Value or 'Y'
TPMossGroup:AddLabel('Keybind: ' .. tpmossKeyText)
TPMossGroup:AddLabel('Hide UI: P')

local HitboxGroup = Tabs.Main:AddRightGroupbox('Hitbox Extender')
HitboxGroup:AddToggle('HitboxToggle', {
    Text = 'Enable Hitbox Extender',
    Default = false,
    Callback = function(Value)
        if Value then
            local hitboxValue = Options.HitboxSlider.Value
            loadstring([[
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Workspace = game:GetService("Workspace")
                local UserInputService = game:GetService("UserInputService")
                local RunService = game:GetService("RunService")
                local scriptActive = true
                local showSphere = true
                local manualSize = ]] .. hitboxValue .. [[
                local currentSize = ]] .. hitboxValue .. [[
                local originalCreate = nil
                local visualizer = nil
                local function updateVisualizer()
                    local tempFolder = Workspace:FindFirstChild("Temp")
                    local ball = tempFolder and tempFolder:FindFirstChild("Ball")
                    local highlight = ball and ball:FindFirstChild("PossessionHighlight")
                    if not highlight then
                        currentSize = 7
                    else
                        currentSize = manualSize
                    end
                    if not ball or not scriptActive or not showSphere then
                        if visualizer then visualizer.Visible = false end
                        return
                    end
                    if not visualizer then
                        visualizer = Instance.new("SphereHandleAdornment")
                        visualizer.Name = "HitboxVisual"
                        visualizer.Color3 = Color3.fromRGB(0, 170, 255)
                        visualizer.Transparency = 0.7
                        visualizer.AlwaysOnTop = true
                        visualizer.ZIndex = 10
                        visualizer.Parent = game.CoreGui
                    end
                    visualizer.Visible = true
                    visualizer.Adornee = ball
                    visualizer.Radius = currentSize / 2
                end
                local function hook()
                    local module = require(ReplicatedStorage.Modules.HitboxHandler)
                    if originalCreate then return end
                    originalCreate = module.Create
                    module.Create = function(config)
                        if scriptActive then
                            config.size = Vector3.new(currentSize, currentSize, currentSize)
                        end
                        return originalCreate(config)
                    end
                end
                UserInputService.InputBegan:Connect(function(input, processed)
                    if processed then return end
                    if input.KeyCode == Enum.KeyCode.Zero then
                        scriptActive = not scriptActive
                        print("Script Active:", scriptActive)
                    elseif input.KeyCode == Enum.KeyCode.H then
                        showSphere = not showSphere
                        if not showSphere and visualizer then visualizer.Visible = false end
                        print("Sphere Visible:", showSphere)
                    elseif input.KeyCode == Enum.KeyCode.M then
                        manualSize = manualSize + 1
                        print("Target Size set to:", manualSize)
                    elseif input.KeyCode == Enum.KeyCode.N then
                        manualSize = math.max(1, manualSize - 1)
                        print("Target Size set to:", manualSize)
                    end
                end)
                RunService.RenderStepped:Connect(updateVisualizer)
                hook()
            ]])()
        end
    end
})

HitboxGroup:AddSlider('HitboxSlider', {
    Text = 'Hitbox Size',
    Default = 15,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Callback = function(Value)
        if Toggles.HitboxToggle.Value then
            loadstring([[
                getgenv().manualSize = ]] .. Value .. [[
                getgenv().currentSize = ]] .. Value .. [[
            ]])()
        end
    end
})

local HeaderGroup = Tabs.Main:AddRightGroupbox('Auto Header')
HeaderGroup:AddToggle('HeaderToggle', {
    Text = 'Enable Auto Header',
    Default = false,
    Callback = function(Value)
        if Value then
            local headerKey = getKeybindEnum(Options.AutoHeaderKeybind) or 'Enum.KeyCode.T'
            
            local script = [[
                --!nocheck
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")
                local UserInputService = game:GetService("UserInputService")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Workspace = game:GetService("Workspace")
                local player = Players.LocalPlayer
                local AutoHeaderKey = ]] .. headerKey .. [[
                local HEADER_ANIM_ID = "rbxassetid://15684799301"
                local slipConeSize = Vector3.new(9, 5, 9)
                local autoHeaderActive = false
                local debounce = false
                local ballWasInside = false
                local gui = Instance.new("ScreenGui")
                gui.IgnoreGuiInset = true
                gui.ResetOnSpawn = false
                gui.Parent = player:WaitForChild("PlayerGui")
                local topBar = Instance.new("Frame")
                topBar.Size = UDim2.new(1, 0, 0, 4)
                topBar.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
                topBar.BorderSizePixel = 0
                topBar.Visible = false
                topBar.Parent = gui
                local Knit = require(ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Knit"))
                Knit.Start():await()
                local HeaderService = Knit.GetService("KeyHandlerService")
                local headerRemote = HeaderService:GetKey("Header")
                local slipCone
                RunService.Heartbeat:Connect(function()
                    if slipCone and slipCone.Parent then return end
                    local container = Workspace:FindFirstChild("CharacterContainer")
                    local charFolder = container and container:FindFirstChild(player.Name)
                    local cone = charFolder and charFolder:FindFirstChild("SlipCone")
                    if cone then
                        slipCone = cone
                        slipCone.CanCollide = false
                        local oldY = cone.Size.Y
                        local bottom = cone.CFrame * CFrame.new(0, -oldY / 2, 0)
                        cone.Size = slipConeSize
                        cone.CFrame = bottom * CFrame.new(0, slipConeSize.Y / 2, 0)
                    end
                end)
                UserInputService.InputBegan:Connect(function(input, gp)
                    if gp then return end
                    if input.KeyCode == AutoHeaderKey then
                        autoHeaderActive = not autoHeaderActive
                    end
                end)
                RunService.Heartbeat:Connect(function()
                    topBar.Visible = autoHeaderActive
                    if not autoHeaderActive or not slipCone or not headerRemote then
                        ballWasInside = false
                        return
                    end
                    local char = player.Character
                    local ball = Workspace:FindFirstChild("Temp") and Workspace.Temp:FindFirstChild("Ball")
                    if not ball then ball = Workspace:FindFirstChild("Ball") end
                    if not char or not ball or ball:FindFirstChild("PossessionHighlight") then
                        ballWasInside = false
                        return
                    end
                    local params = OverlapParams.new()
                    params.FilterType = Enum.RaycastFilterType.Include
                    params.FilterDescendantsInstances = { ball }
                    if #Workspace:GetPartsInPart(slipCone, params) == 0 then
                        ballWasInside = false
                        return
                    end
                    if debounce or ballWasInside then return end
                    ballWasInside = true
                    debounce = true
                    task.spawn(function()
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                        task.wait(0.1)
                        local cam = Workspace.CurrentCamera
                        local dir = cam.CFrame.LookVector * 140
                        dir = Vector3.new(dir.X, math.clamp(dir.Y, 12, 24), dir.Z)
                        headerRemote:FireServer(dir, ball)
                        local animator = humanoid and humanoid:FindFirstChildOfClass("Animator")
                        if animator then
                            local anim = Instance.new("Animation")
                            anim.AnimationId = HEADER_ANIM_ID
                            animator:LoadAnimation(anim):Play()
                        end
                        task.wait(0.5)
                        debounce = false
                    end)
                end)
            ]]
            loadstring(script)()
        end
    end
})

local headerKeyText = Options.AutoHeaderKeybind and Options.AutoHeaderKeybind.Value or 'T'
HeaderGroup:AddLabel('Keybind: ' .. headerKeyText)

local AutoGkGroup = Tabs.Main:AddRightGroupbox('Auto GK')
AutoGkGroup:AddToggle('AutoGkToggle', {
    Text = 'Enable Auto GK',
    Default = false,
    Callback = function(Value)
        if Value then
            local gkKey = getKeybindEnum(Options.AutoGkKeybind) or 'Enum.KeyCode.One'
            
            local script = [[
                local RunService = game:GetService("RunService")
                local Workspace = game:GetService("Workspace")
                local Players = game:GetService("Players")
                local VirtualInputManager = game:GetService("VirtualInputManager")
                local UserInputService = game:GetService("UserInputService")
                local Player = Players.LocalPlayer
                local Character = Player.Character or Player.CharacterAdded:Wait()
                local RootPart = Character:WaitForChild("HumanoidRootPart")
                local CONFIG = {
                	Enabled = true,
                	ShowVisuals = false,
                	ActivationKey = ]] .. gkKey .. [[,
                	MinBallVelocity = 10,
                	DelayMidDive  = 0.02,
                	DelayHighDive = 0.13,
                	TimeThresholdFar    = 0.32,
                	TimeThresholdMidFar = 0.23,
                	TimeThresholdMid    = 0.2,
                	Height_Split_LowMid = -1.0,
                	Height_Split_MidHigh = 3,
                	ReachX = 40,
                	ReachY = 25,
                	BallRadius = 1.0,
                	BounceElasticity = 0.7,
                	Gravity = Vector3.new(0, -workspace.Gravity, 0),
                	Keys = {
                		Left = Enum.KeyCode.A,
                		Right = Enum.KeyCode.D,
                		Jump = Enum.KeyCode.Space
                	}
                }
                local DiveCooldown = false
                local VisContainer = Instance.new("Folder", Workspace)
                VisContainer.Name = "GK_Exact_Plane_System"
                local function DrawPoint(pos, col, size)
                	if not CONFIG.ShowVisuals then return end
                	local p = Instance.new("Part")
                	p.Anchored, p.CanCollide, p.CastShadow = true, false, false
                	p.Shape, p.Material = "Ball", "Neon"
                	p.Size = Vector3.new(size, size, size)
                	p.Position = pos
                	p.Color = col
                	p.Parent = VisContainer
                	game.Debris:AddItem(p, 0.1)
                end
                local function PerformDive(Direction, Mode)
                	if DiveCooldown then return end
                	DiveCooldown = true
                	local holdKey = nil
                	if Direction == "Right" then holdKey = CONFIG.Keys.Right
                	elseif Direction == "Left" then holdKey = CONFIG.Keys.Left
                	end
                	task.spawn(function()
                		if holdKey then
                			VirtualInputManager:SendKeyEvent(true, holdKey, false, game)
                		end
                		if Mode == "High" then
                			VirtualInputManager:SendKeyEvent(true, CONFIG.Keys.Jump, false, game)
                			task.wait(CONFIG.DelayHighDive)
                			VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 1)
                		elseif Mode == "Mid" then
                			VirtualInputManager:SendKeyEvent(true, CONFIG.Keys.Jump, false, game)
                			task.wait(CONFIG.DelayMidDive)
                			VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 1)
                		elseif Mode == "Low" then
                			VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 1)
                		end
                		task.wait(0.1)
                		VirtualInputManager:SendMouseButtonEvent(0, 0, 1, false, game, 1)
                		if Mode == "High" or Mode == "Mid" then
                			VirtualInputManager:SendKeyEvent(false, CONFIG.Keys.Jump, false, game)
                		end
                		if holdKey then
                			VirtualInputManager:SendKeyEvent(false, holdKey, false, game)
                		end
                		task.wait(0.8)
                		DiveCooldown = false
                	end)
                end
                local function GetReactionThreshold(sidewaysDist)
                	local DistCenter, DistFar = 4.0, 16.0
                	if sidewaysDist >= DistFar then return CONFIG.TimeThresholdFar end
                	if sidewaysDist <= DistCenter then return CONFIG.TimeThresholdMid end
                	local alpha = (sidewaysDist - DistCenter) / (DistFar - DistCenter)
                	return CONFIG.TimeThresholdMid + (CONFIG.TimeThresholdFar - CONFIG.TimeThresholdMid) * alpha
                end
                local function Update(dt)
                	if not CONFIG.Enabled or not RootPart then return end
                	if not UserInputService:IsKeyDown(CONFIG.ActivationKey) then
                		return
                	end
                	local Ball = Workspace:FindFirstChild("Temp") and Workspace.Temp:FindFirstChild("Ball")
                	if not Ball then Ball = Workspace:FindFirstChild("Ball") end
                	if not Ball then return end
                	local currentVel = Ball.AssemblyLinearVelocity
                	if currentVel.Magnitude < CONFIG.MinBallVelocity then return end
                	local externalAcc = Vector3.zero
                	local mfObj = Ball:FindFirstChildWhichIsA("VectorForce", true)
                	if mfObj and mfObj.Enabled then
                		local rawForce = mfObj.Force
                		if mfObj.RelativeTo == Enum.ActuatorRelativeTo.Attachment0 and mfObj.Attachment0 then
                			rawForce = mfObj.Attachment0.WorldCFrame:VectorToWorldSpace(rawForce)
                		elseif mfObj.RelativeTo == Enum.ActuatorRelativeTo.Attachment1 and mfObj.Attachment1 then
                			rawForce = mfObj.Attachment1.WorldCFrame:VectorToWorldSpace(rawForce)
                		end
                		externalAcc = rawForce / Ball.AssemblyMass
                	end
                	local simPos = Ball.Position
                	local simVel = currentVel
                	local stepDt = 0.015
                	local rootCF = RootPart.CFrame
                	local startRelPos = rootCF:PointToObjectSpace(simPos)
                	local lastRelZ = startRelPos.Z
                	for i = 1, 100 do
                		local oldPos = simPos
                		local oldRelZ = lastRelZ
                		simVel = simVel + ((CONFIG.Gravity + externalAcc) * stepDt)
                		simPos = simPos + (simVel * stepDt)
                		if simPos.Y < CONFIG.BallRadius then
                			simPos = Vector3.new(simPos.X, CONFIG.BallRadius, simPos.Z)
                			simVel = Vector3.new(simVel.X, -simVel.Y * CONFIG.BounceElasticity, simVel.Z)
                	 end
                		if CONFIG.ShowVisuals and i % 3 == 0 then
                			DrawPoint(simPos, Color3.new(1,0,0), 0.2)
                		end
                		local currentRelPos = rootCF:PointToObjectSpace(simPos)
                		local currentRelZ = currentRelPos.Z
                		if (oldRelZ * currentRelZ) <= 0 then
                			local totalZDist = math.abs(oldRelZ - currentRelZ)
                			local alpha = 0
                			if totalZDist > 0.0001 then alpha = math.abs(oldRelZ) / totalZDist end
                			local exactImpactPos = oldPos:Lerp(simPos, alpha)
                			local relImpact = rootCF:PointToObjectSpace(exactImpactPos)
                			local impactTime = (i - 1 + alpha) * stepDt
                			if relImpact.Y > -5 and relImpact.Y < CONFIG.ReachY and math.abs(relImpact.X) < CONFIG.ReachX then
                				local sidewaysDist = math.abs(relImpact.X)
                				local relativeHeight = relImpact.Y
                				if impactTime <= GetReactionThreshold(sidewaysDist) then
                					local mode = "Low"
                					local color = Color3.new(0,1,0)
                					if relativeHeight < CONFIG.Height_Split_LowMid then
                						mode = "Low"
                						color = Color3.new(0, 1, 0)
                					elseif relativeHeight <= CONFIG.Height_Split_MidHigh then
                						mode = "Mid"
                						color = Color3.new(1, 0.5, 0)
                					else
                						mode = "High"
                						color = Color3.new(1, 0, 1)
                					end
                					local dir = "Center"
                					if relImpact.X > 2.5 then dir = "Right"
                					elseif relImpact.X < -2.5 then dir = "Left"
                					end
                					DrawPoint(exactImpactPos, color, 1.0)
                					PerformDive(dir, mode)
                				end
                			end
                			break
                		end
                		lastRelZ = currentRelZ
                	end
                end
                RunService.RenderStepped:Connect(Update)
            ]]
            loadstring(script)()
        end
    end
})

local gkKeyText = Options.AutoGkKeybind and Options.AutoGkKeybind.Value or '1'
AutoGkGroup:AddLabel('Keybind: ' .. gkKeyText)

local ZoomGroup = Tabs.Main:AddRightGroupbox('Zoom')
ZoomGroup:AddToggle('ZoomToggle', {
    Text = 'Enable Zoom',
    Default = false,
    Callback = function(Value)
        if Value then
            loadstring([[
                local Players = game:GetService("Players")
                local player = Players.LocalPlayer
                player.CameraMaxZoomDistance = 10000
            ]])()
        else
            loadstring([[
                local Players = game:GetService("Players")
                local player = Players.LocalPlayer
                player.CameraMaxZoomDistance = 12
            ]])()
        end
    end
})

-- NEW BALL TRAIL GROUP
local BallTrailGroup = Tabs.Main:AddRightGroupbox('Ball Trail')
BallTrailGroup:AddToggle('BallTrailToggle', {
    Text = 'Enable Custom Trail',
    Default = false,
    Callback = function(Value)
        if Value then
            local color1 = Options.BallTrailColor1 and Options.BallTrailColor1.Value or Color3.new(0, 0.712, 1)
            local color2 = Options.BallTrailColor2 and Options.BallTrailColor2.Value or Color3.new(1, 0, 0)
            local mode = Options.BallTrailMode and Options.BallTrailMode.Value or 'Single Color'
            
            local script = [[
                local Workspace = game:GetService("Workspace")
                local RunService = game:GetService("RunService")
                
                local function updateTrail()
                    local ball = Workspace:FindFirstChild("Temp") and Workspace.Temp:FindFirstChild("Ball")
                    if not ball then return end
                    
                    -- Update IFrameTrail
                    local iframeTrail = ball:FindFirstChild("IFrameTrail")
                    if iframeTrail then
                        ]] .. (mode == 'Gradient' and [[
                        iframeTrail.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, Color3.new(]] .. color1.R .. [[, ]] .. color1.G .. [[, ]] .. color1.B .. [[)),
                            ColorSequenceKeypoint.new(1, Color3.new(]] .. color2.R .. [[, ]] .. color2.G .. [[, ]] .. color2.B .. [[))
                        }
                        ]] or [[
                        iframeTrail.Color = ColorSequence.new(Color3.new(]] .. color1.R .. [[, ]] .. color1.G .. [[, ]] .. color1.B .. [[))
                        ]]) .. [[
                    end
                    
                    -- Update regular Trail
                    local regularTrail = ball:FindFirstChild("Trail")
                    if regularTrail then
                        ]] .. (mode == 'Gradient' and [[
                        regularTrail.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, Color3.new(]] .. color1.R .. [[, ]] .. color1.G .. [[, ]] .. color1.B .. [[)),
                            ColorSequenceKeypoint.new(1, Color3.new(]] .. color2.R .. [[, ]] .. color2.G .. [[, ]] .. color2.B .. [[))
                        }
                        ]] or [[
                        regularTrail.Color = ColorSequence.new(Color3.new(]] .. color1.R .. [[, ]] .. color1.G .. [[, ]] .. color1.B .. [[))
                        ]]) .. [[
                    end
                end
                
                -- Initial update
                updateTrail()
                
                -- Monitor for ball changes
                local tempFolder = Workspace:WaitForChild("Temp")
                if tempFolder then
                    tempFolder.ChildAdded:Connect(function(child)
                        if child.Name == "Ball" then
                            task.wait(0.1)
                            updateTrail()
                        end
                    end)
                end
                
                -- Continuous update for safety
                RunService.Heartbeat:Connect(updateTrail)
            ]]
            loadstring(script)()
        end
    end
})

BallTrailGroup:AddDropdown('BallTrailMode', {
    Values = {'Single Color', 'Gradient'},
    Default = 'Single Color',
    Multi = false,
    Text = 'Trail Type',
})

BallTrailGroup:AddColorPicker('BallTrailColor1', {
    Default = Color3.new(0, 0.712, 1),
    Title = 'Primary Color',
})

BallTrailGroup:AddColorPicker('BallTrailColor2', {
    Default = Color3.new(1, 0, 0),
    Title = 'Secondary Color',
})

BallTrailGroup:AddLabel('Controls both IFrameTrail and Trail')

-- RIN PACK GROUP
local RinPackGroup = Tabs.Main:AddRightGroupbox('Animation Pack')
RinPackGroup:AddToggle('RinPackToggle', {
    Text = 'Enable Rin Pack',
    Default = false,
    Callback = function(Value)
        Library:Notify('Rin Pack ' .. (Value and 'enabled' or 'disabled'), 3)
    end
})

RinPackGroup:AddLabel('Replaces Aimbot V1 and Prehold animations')
RinPackGroup:AddLabel('Does NOT affect: Double Tap, Phys Reach, Auto Flick')

-- INTERPOLATION TAB
local InterpGroup = Tabs.Interpolation:AddLeftGroupbox('Interpolation')
local interpValues = {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 5}

for i = 1, math.min(10, #interpValues) do
    InterpGroup:AddButton(interpValues[i] .. ' Interpolation', function()
        pcall(function()
            setfflag("InterpolationMaxDelayMSec", tostring(interpValues[i]))
            Library:Notify('Set interpolation to: ' .. interpValues[i], 3)
        end)
    end)
end

local InterpGroup2 = Tabs.Interpolation:AddLeftGroupbox('Interpolation (Continued)')
for i = 11, #interpValues do
    InterpGroup2:AddButton(interpValues[i] .. ' Interpolation', function()
        pcall(function()
            setfflag("InterpolationMaxDelayMSec", tostring(interpValues[i]))
            Library:Notify('Set interpolation to: ' .. interpValues[i], 3)
        end)
    end)
end

-- NEW DYNAMIC INTERPOLATION FEATURE
local DynamicInterpGroup = Tabs.Interpolation:AddRightGroupbox('Dynamic Interpolation')
DynamicInterpGroup:AddToggle('DynamicInterpToggle', {
    Text = 'Enable Dynamic Interpolation',
    Default = false,
    Callback = function(Value)
        if Value then
            local normalInterp = Options.NormalInterpSlider and Options.NormalInterpSlider.Value or 35
            local ballInterp = Options.BallInterpSlider and Options.BallInterpSlider.Value or 15
            
            loadstring([[
                local Workspace = game:GetService("Workspace")
                local RunService = game:GetService("RunService")
                
                local normalInterp = ]] .. normalInterp .. [[
                local ballInterp = ]] .. ballInterp .. [[
                
                local function getBall()
                    local tempFolder = Workspace:FindFirstChild("Temp")
                    return tempFolder and tempFolder:FindFirstChild("Ball") or Workspace:FindFirstChild("Ball")
                end
                
                local function hasBall()
                    local ball = getBall()
                    if ball then
                        local highlight = ball:FindFirstChild("PossessionHighlight")
                        return highlight and true or false
                    end
                    return false
                end
                
                RunService.Heartbeat:Connect(function()
                    if hasBall() then
                        setfflag("InterpolationMaxDelayMSec", tostring(ballInterp))
                    else
                        setfflag("InterpolationMaxDelayMSec", tostring(normalInterp))
                    end
                end)
            ]])()
        else
            setfflag("InterpolationMaxDelayMSec", tostring(35))
        end
    end
})

DynamicInterpGroup:AddSlider('NormalInterpSlider', {
    Text = 'Normal Interpolation',
    Default = 35,
    Min = 5,
    Max = 100,
    Rounding = 0,
})

DynamicInterpGroup:AddSlider('BallInterpSlider', {
    Text = 'With Ball Interpolation',
    Default = 15,
    Min = 5,
    Max = 100,
    Rounding = 0,
})

DynamicInterpGroup:AddLabel('Automatically changes interpolation')
DynamicInterpGroup:AddLabel('when you have ball possession')

-- CONFIGURATION TAB
local KeybindGroup = Tabs.Configuration:AddLeftGroupbox('Keybind Configuration')

-- Add all keybind pickers first
local keybindOptions = {
    {name = 'AutoHeaderKeybind', default = 'T', text = 'Auto Header Key'},
    {name = 'TPMossKeybind', default = 'Y', text = 'TP Moss Key'},
    {name = 'DoubleTapKeybind', default = 'X', text = 'Double Tap Key'},
    {name = 'AutoGkKeybind', default = 'One', text = 'Auto GK Key'},
    {name = 'AimbotHighKeybind', default = 'V', text = 'Aimbot V1 High Key'},
    {name = 'AimbotLowKeybind', default = 'B', text = 'Aimbot V1 Low Key'},
    {name = 'AimbotV2TopKeybind', default = 'One', text = 'Aimbot V2 Top Key'},
    {name = 'AimbotV2BottomKeybind', default = 'Two', text = 'Aimbot V2 Bottom Key'},
    {name = 'PreholdToggleKeybind', default = 'Four', text = 'Auto Prehold Toggle'},
    {name = 'PreholdManualKeybind', default = 'G', text = 'Auto Prehold Manual'},
    {name = 'AutoM2Keybind', default = 'Three', text = 'Auto M2 Toggle'},
    {name = 'PhysReachKeybind', default = 'R', text = 'Phys Reach Key'},
    {name = 'AutoFlickKeybind', default = 'Five', text = 'Auto Flick Key'},
    {name = 'LastDiscKeybind', default = 'J', text = 'Auto Last Disc Key'},
}

for _, option in ipairs(keybindOptions) do
    KeybindGroup:AddLabel(option.text):AddKeyPicker(option.name, {
        Default = option.default,
        NoUI = false,
        Text = option.text,
        Mode = 'Toggle',
    })
end

local SettingsGroup = Tabs.Configuration:AddRightGroupbox('Settings')

local sliderOptions = {
    {name = 'SpeedDefaultSlider', default = 1.24, min = 1.00, max = 5.00, rounding = 2, text = 'Default Speed Multiplier', target = 'SpeedSlider'},
    {name = 'HitboxDefaultSlider', default = 15, min = 1, max = 50, rounding = 0, text = 'Default Hitbox Size', target = 'HitboxSlider'},
    {name = 'AimbotPowerDefaultSlider', default = 100, min = 100, max = 999, rounding = 0, text = 'Default Aimbot Power', target = 'AimbotPowerSlider'},
    {name = 'PreholdRangeDefaultSlider', default = 4, min = 1, max = 15, rounding = 1, text = 'Default Prehold Range', target = 'PreholdRangeSlider'},
    {name = 'AimbotV2RangeDefaultSlider', default = 7, min = 1, max = 20, rounding = 0, text = 'Default Aimbot V2 Range', target = 'AimbotV2RangeSlider'},
    {name = 'AimbotV2CooldownDefaultSlider', default = 1, min = 0.1, max = 5, rounding = 1, text = 'Default Aimbot V2 Cooldown', target = 'AimbotV2CooldownSlider'},
    {name = 'AimbotV2PowerDefaultSlider', default = 140, min = 100, max = 999, rounding = 0, text = 'Default Aimbot V2 Power', target = 'AimbotV2PowerSlider'},
    {name = 'AutoFlickPowerDefaultSlider', default = 27.13, min = 10, max = 50, rounding = 2, text = 'Default Auto Flick Power', target = 'AutoFlickPowerSlider'},
    {name = 'AutoFlickXDefaultSlider', default = 14.28, min = 5, max = 50, rounding = 2, text = 'Default Auto Flick X', target = 'AutoFlickXSlider'},
    {name = 'AutoFlickYDefaultSlider', default = 21.85, min = 5, max = 50, rounding = 2, text = 'Default Auto Flick Y', target = 'AutoFlickYSlider'},
    {name = 'AutoFlickZDefaultSlider', default = 32.02, min = 5, max = 50, rounding = 2, text = 'Default Auto Flick Z', target = 'AutoFlickZSlider'},
    {name = 'NormalInterpDefaultSlider', default = 35, min = 5, max = 100, rounding = 0, text = 'Default Normal Interpolation', target = 'NormalInterpSlider'},
    {name = 'BallInterpDefaultSlider', default = 15, min = 5, max = 100, rounding = 0, text = 'Default Ball Interpolation', target = 'BallInterpSlider'},
}

for _, option in ipairs(sliderOptions) do
    SettingsGroup:AddSlider(option.name, {
        Text = option.text,
        Default = option.default,
        Min = option.min,
        Max = option.max,
        Rounding = option.rounding,
        Callback = function(Value)
            if Options[option.target] then
                Options[option.target]:SetValue(Value)
            end
        end
    })
end

SettingsGroup:AddButton('Reset All Settings', function()
    local togglesToReset = {
        'SpeedToggle', 'StaminaToggle', 'KickToggle', 'LastDiscToggle', 'TPMossToggle',
        'HitboxToggle', 'HeaderToggle', 'AutoGkToggle', 'ZoomToggle', 'AimbotToggle',
        'AimbotV2Toggle', 'PreholdToggle', 'DoubleTapToggle', 'AutoM2Toggle',
        'DynamicInterpToggle', 'PhysReachToggle', 'AutoFlickToggle', 'BallTrailToggle',
        'RinPackToggle'
    }
    
    for _, toggleName in ipairs(togglesToReset) do
        if Toggles[toggleName] then
            Toggles[toggleName]:SetValue(false)
        end
    end
    
    -- Reset sliders
    Options.SpeedSlider:SetValue(1.24)
    Options.HitboxSlider:SetValue(15)
    Options.AimbotPowerSlider:SetValue(100)
    Options.PreholdRangeSlider:SetValue(4)
    Options.AimbotV2RangeSlider:SetValue(7)
    Options.AimbotV2CooldownSlider:SetValue(1)
    Options.AimbotV2PowerSlider:SetValue(140)
    Options.AutoFlickPowerSlider:SetValue(27.13)
    Options.AutoFlickXSlider:SetValue(14.28)
    Options.AutoFlickYSlider:SetValue(21.85)
    Options.AutoFlickZSlider:SetValue(32.02)
    Options.NormalInterpSlider:SetValue(35)
    Options.BallInterpSlider:SetValue(15)
    
    -- Reset other options
    if Options.BallTrailMode then Options.BallTrailMode:SetValue('Single Color') end
    if Options.BallTrailColor1 then Options.BallTrailColor1:SetValue(Color3.new(0, 0.712, 1)) end
    if Options.BallTrailColor2 then Options.BallTrailColor2:SetValue(Color3.new(1, 0, 0)) end
    
    Library:Notify('All settings reset to default', 3)
end)

-- UI Settings
Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter = FrameCounter + 1

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    Library:SetWatermark(('Vevo Hub v1.3 | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ))
end)

Library.KeybindFrame.Visible = true

Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    print('Unloaded!')
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind 

-- Apply theme with accent color
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('VevoHub')
SaveManager:SetFolder('VevoHub/Freestyle Football')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()
